\documentclass[12pt,msc,a4paper,oneside]{ucl_thesis}
%\documentclass[12pt,mres,draft,a4paper,oneside]{ucl_thesis}

\usepackage{graphicx}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{tabularx}

\DeclareMathOperator{\Btcstate}{S}
\DeclareMathOperator{\Btctransaction}{T}
\DeclareMathOperator{\btctransaction}{t}
\DeclareMathOperator{\Btcinput}{I}
\DeclareMathOperator{\btcinput}{i}
\DeclareMathOperator{\Btcoutput}{O}
\DeclareMathOperator{\btcoutput}{o}

\DeclareMathOperator{\Receipt}{R}
\DeclareMathOperator{\receipt}{r}

\DeclareMathOperator{\Metalang}{\mathcal{L}_m}
\DeclareMathOperator{\metaop}{\mathcal{o}_m}

\DeclareMathOperator{\Proplang}{\mathcal{L}(N)}
\DeclareMathOperator{\proplang}{\ell}
\DeclareMathOperator{\Propatom}{A}
\DeclareMathOperator{\propatom}{a}
\DeclareMathOperator{\Propvar}{F}
\DeclareMathOperator{\propvar}{f}
\DeclareMathOperator{\Propdom}{D}
\DeclareMathOperator{\Predicate}{C}
\DeclareMathOperator{\Interpretation}{I}
\DeclareMathOperator{\Ontology}{O}
\DeclareMathOperator{\Deal}{D}
\DeclareMathOperator{\deal}{d}
\DeclareMathOperator{\demand}{\delta}
\DeclareMathOperator{\offer}{\omega}

\DeclareMathOperator{\nonce}{n}


\DeclareMathOperator{\Statement}{S}
\DeclareMathOperator{\statement}{s}
\DeclareMathOperator{\statementtext}{t}
\DeclareMathOperator{\sentence}{sent}
\DeclareMathOperator{\Issue}{I}
\DeclareMathOperator{\issue}{i}
\DeclareMathOperator{\Party}{P}
\DeclareMathOperator{\party}{p}
\DeclareMathOperator{\Numparties}{N}
\DeclareMathOperator{\Constraint}{C}
\DeclareMathOperator{\constraint}{c}

\DeclareMathOperator{\Doc}{D}
\DeclareMathOperator{\doc}{d}
\DeclareMathOperator{\docack}{d^*}
\DeclareMathOperator{\Docack}{D^*}
\DeclareMathOperator{\owner}{o}
\DeclareMathOperator{\recipient}{r}
\DeclareMathOperator{\doctitle}{t}
\DeclareMathOperator{\content}{m}
\DeclareMathOperator{\statetransferfunc}{\delta}

\DeclareMathOperator{\docreceipt}{\receipt_{\doc}}
\DeclareMathOperator{\docackreceipt}{\receipt_{\docack}}
\DeclareMathOperator{\keydocowner}{K_{{\party}_{\owner}}}
\DeclareMathOperator{\keydocrecipient}{K_{{\party}_{\recipient}}}
\DeclareMathOperator{\keydocument}{K_{\doc}}

\pdfimageresolution=600
% The setspace package lets you use 1.5-sized or double line spacing.
%\setstretch{1.5}

% Title Settings
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\title{Alternative Dispute Resolution Using Blockchain Technologies}
\author{Christoph Sitter
}
    %Supervisor - Prof. Philip Treleaven \\
    %Supervisor - Prof. Tomasz Mloduchowski
\department{Department of Computer Science}

\begin{document}

\maketitle
\makedeclaration

% 02p    - Abstract
%         - 1 - 1.5 pages
%         - Start saying: This dissertation investigates ..., and why this is important
%         - Design, Implemntation, Tests & Results. Factual, keep it brief, no discussion

\setstretch{1.0}
\begin{abstract}
    This thesis investigates the applicability of blockchain technologies to Alternative Dispute Resolution, ADR. More precisely, designing an Online Dispute Resolution, ODR, system that is blockchain agnostic as well as does not require a neutral third party as an intermediary. Online Dispute Resolution merely refers to any online service that allows parties to engage in a dispute resolution process. The thesis starts by investigating scalability as well as safety guarantees and potential risks involved with blockchains, then defines a protocol for disclosure using blockchain, describes the design and implementation of a blockchain agnostic anchoring tool developed in the course of this work, briefly outlines associating identities with public keys and provides a protocol design for two parties to argue a dispute in a provable and verifiable way using a blockchain agnostic protocol and formalism.

    \textbf{Safety and performance properties} of blockchain technologies are important to understand. The technology itself has certain limitations with respect to performance and scalability as well as safety and part one if this work outlines the safety guarantees provided as well as the scalability considerations and problems with current incarnations of blockchain technologies. The design of the ADR system developed in this work is influenced by these properties as tamper resistance requirements as well as timely confirmations are a requirement in litigation.

    \textbf{Discovery/Disclosure} is the pre-dispute phase of litigation and describes the process in which documents are disclosed to the other party.\footnote{For the purpose of this work this choice of terminology is used throughout, under the context of civil litigaton in England and Wales, the term Disclosure is used instead of Discovery.} In the second part of this thesis, a blockchain agnostic protocol for disclosure is designed and a prototype for it implemented. The prototype includes an implementation of a blockchain agnostic service that allows anchoring of arbitrary data into a blockchain and is based on the service provided by the company Tierion as well as a basic webpage showing how disclosure would work.

    \textbf{Key Management} is a broad topic on it's own and includes Key generation, key storage and associating identity with keys amongs others. Because parties in the context of blockchains are represented by public keys, it is important to be able to proof the identity of an entity behind a public key. While this work does not focus on this part of the system, it briefly outlines options for associating identity with public keys.

    \textbf{Dispute} can be seen as negotiation between parties over certain issues or resources that they wish to divide up evenly. In this work a system is designed, that allows parties to argue over issues using blockchain technologies while not requiring a third party to verify certain statements have been made and agreement has been reached. This works by keeping all interactions in the immutable ledger a blockchain is for future reference. If no mutually satisfying solution can be found, the interactions and documents used in this process can easily be used as evidence in a formal litigation setting. In addition to providing a framework to facilitate disputes, it investigates negotiation support without the need for a third party based on game theoretic approaches as defined by Nash and expanded on by Rubenstein.

    While ODR is a well studied field with various different approaches to how negotiation is supported, this work presents a novel blockchain based framework for logic based negotiation that does not involve a neutral third party. To the best of our knowledge, this has not been researched before and combines research from negotiation theory, propositional logic, linear programming as well as advanced crypography. The proposed framework defines all components required to provide an end-to-end system for alternative dispute resolution, designed as individual, stand alone, parts that together form a full system and concludes with a discussion about the problems of the system design as well as future work to address these issues.

\end{abstract}

\begin{acknowledgements}
    This work would not have been possible without the support from the people around me. Throughout this troubled project, where the supposed project team fell apart and the industry supervisor was largely unavailable I received continued support and guidance from Prof. Philip Treleaven without whom I would not have been able to finish this work. I also would like to thank my employer Caplin Systems Ltd\footnote{www.caplin.com} for letting me work on a 40\% part time basis throughout the course and giving me the time off I needed when I needed it withouth which it would have been impossible to complete this work.
\end{acknowledgements}

\setcounter{tocdepth}{2}

\tableofcontents
\listoffigures
\listoftables

\setstretch{1.5}
\chapter{Introduction}
\label{sec:introduction}
In this chapter, an overview of the thesis is presented. It starts by presenting the research motivation for the project, followed by the defined objectives and the research outcomes. It explains the structure of this dissertation and concludes with the scientific contributions of this work.

\section{Research Motivations}
Litigation is a lengthy and costly process and in a lot of cases it is more efficient to settle disputes in an alternative dispute resolution, ADR, setting. ADR refers to the process of settling disputes outside of a court of law through mechanisms like Arbitration or Mediation. With almost every person on the planet having access to the Internet and a PC it was only natural that these dispute techniques were moved to the internet, typically referred to as online dispute resolution or ODR. According to \cite{katsh:odr}, ODR borrows the frameworks from offline approaches like Mediation or Arbitration and applies technical resources to it to provide an overall better service. A lot of companies have taken ADR approaches online to provide an ORD framework, and prominent ones inclue eBay, CyberSettle and SmartSettle. Cortez \cite{cortes2011online} states that the advanteages of ODR over traditional approaches are time savings, convenience of the procedure, cost savings, control over outcomes as well as appropriateness, while having the disadvantages of lack of face-to-face contact, technological problems, language barriers, legal difficulties, need for party consent as well as loss of public access, which due to the private nature of Mediation and Arbitration is not an issue.

Disputes can typically be broken into two main areas, discovery and negotiation over issues or resources always involving a third party. In discovery, it is important that a document is made available to the other party, with a guarantee that the documen cannot be tampered with as well as the option to proof that the document was disclosed. In the negotiation phase it is important, that the interactions between parties are traceable and verifiable as well as it needs to be possible to proof that at a certain point in time an agreement was reached. In traditional offline, as well as online settings, there is typically a neutral third party involved that can provide these guarantees. This itself however comes with certain concerns on it's own. What if the third party does not have the domain knowledge to make informed suggestions, what if they are not as impartial as they should be amongs others. This is what the blockchain can potentially address by removing the need for a neutral third party and instead using a combination of blockchains and negotiation tools to provide the same guarantees.

Ever since the invention of Bitcoin, the field of crypto currencies has become more and more popular. In this particular context the more interesting aspect of the technology, is the underlying protocol for distributed consensus and globally unique timestamping, called the blockchain. Due to the tamper resistance and cryptographic guarantees they provide, some of the tasks that would have typically be performed by a Notary or neutral third party, can now be done online, between two parties directly.


\section{Research Objectives}
The objective of this research is to investigate the applicability of blockchain technologies to the domain of ODR with a focus on developing a prototype blockchain anchoring system to act as a notary type service for disclosure as well as the design of a meta-language, DSL, as well as a protocol that can be used on top of this prototype to facilitate structured negotiation between parties to be used for dispute resolution in a blockchan agnostic manner. The main hypothesis of this research states:
\\\textit{Using blockchain technologies it is possible to eliminate the need for a neutral third party in alternative dispute resolution processes.}
To validate this hypothesis, there are three main tasks that need to be solved in this research, Discovery, Negotiation and Negotiation Support.

\textbf{Discovery}, the first task that needs to be solved, is defined as \textit{"A party discloses a document by stating that the document exists or has existed."} in the Part 31 of Civil Procedure Rules of England and Wales \cite{justice_gov:civil_procedure_rules}. The objective is to develop a protocol that allows two parties to disclose documents to each other using blockchain anchoring. A blockchain agnostic library for anchoring data needs to be developed and a protocol defined that works on top of this prototype and provides both parties with a way to proof that a document was disclosed by another party. It is important to note that this work does not include any guarantees that all relevant documents are disclosed, as well as even though it should be possible to proof that a certain document was disclosed, it may not be legal to do so as Mediation and Arbitration are private processes and neither party has the right to disclose any of contents of the Mediation/Arbitration unless agreed upon otherwise.

\textbf{Negotiation}, the second task is a well studied domain with a wide range of approaches and applcations. The objective here is to design a formalism, as well as a protocol, that in combination with the anchoring library provides a way for two parties to negotiate a dispute and reach a conclusion, agreement or disagreement, that either party can later on verify and proof. In addition to this, it should be possible to take the negotiation history to a court of law in case of a disagreement to speed up litigation processes. This however needs to be agreed upon by both parties as the Mediation/Arbitration process is private.

\textbf{Negotiation Support}, the last task that needs to be investigated is supporting negotiation between parties. In a real setting, the role of a Mediator/Arbitrator is not only helping to reach consensus, but also to guide the parties through the process and give legal support. This task does not aim to provide all the support a person could provide, but focuses on finding a pareto optimal agreement between parties using the formalism of the previous objective using game theory, blockchains and multi-party computation.

\section{Research/Project impediments}
This work was originally intended to be performed by a group of at least two people with support from an industry supervisor. Due to unfortunate circumstances, the team fell apart before the project even kicked off properly and the industry supervisor was not available to provide guidance apart from setting out the original direction. This left me having to work on the project alone which, due to the it's huge scope and cross-domain nature made it extremely challenging.

\section{Research Outcomes} \label{sec:research_outcomes}
Despite the impediments that were faced in the project almost all of the set objectives were met. Ideally a prototype for the negotiation support would have been implemented as well, but due to timely limitations and the already very large scope of this work it had to be left for future research.

\textbf{Discovery}, the first task was fully solved, a prototype for an anchoring system was developed as well as a prototype web page for discovery/disclosure. While the blockchain does fit the requirements and needs for document disclosure very well, there exists a major issue with this approach, namely that documents aren't stored in the blockchain, only a hash which means that unless one is in possession of the document, there is no way to associate any information with the anchored hash. Storing full documents on a blockchain however is not feasible and won't ever be an option.

\textbf{Negotiation}, the second task was defined and a domain specific language that supports the objectives is designed and described in chapter \ref{chapter:dispute}. The objective was to design a DSL that can be used with the developed anchoring tool which was met, it is however worth pointing out, that using smart contracts the same process can be followed while providing extra visibility of the dispute state.

\textbf{Negotiation Support}, the last task was solved by combining multi-party computation, privacy preserving linear programming and the designed negotiation protocol successfully. The research however outlined some major problems with blockchains with respect to secrecy of utility and constraints, as by their nature - especially if one uses Ethereum smart contracts or similar systems - all data is public and it is near impossible to provide perfect secrecy.

\section{Dissertation Structure}
The structure of this dissertation is as follows:

\begin{itemize}
    \item Chapter \ref{chapter:background_and_literature} reviews relevant technologies and concepts for the domain of blockchain based dispute resolution, including basic public key cryptographic concepts, Bitcoin, Ethereum, the Chainpoint blockchain anchoring standard, alternative dispute resolution as well as boolean satisfiability and covers existing blockchain anchoring services, ODR systems as well as multi-party computation for use in the context of negotiation support.

    \item Chapter \ref{chapter:properties_of_blockchains} summarizes guarantees, blockchains in their current incarnations provide as well as gives a brief overview of problems that affect them with partial resolutions.

    \item Chapter \ref{chapter:anchoring_data_into_the_blockchain} formalises what disclosure is and derives a formal protocol and process that can be used for discovery using blockchains in a blockchain agnostic setting. It also outlines the Chainpoint standard and describes the implementation of a Tierion-based blockchain agnostic anchoring library.

    \item Chapter \ref{chapter:key_management} is included for completeness and provides a summary of Key Management approaches with a focus on associating identity with public keys.

    \item Chapter \ref{chapter:dispute} formally defines a dispute and the concept of a resolution. Based on this formalism then defines a domain specific language and protocol that allows parties to negotiate a dispute using the blockchain anchoring library of chapter \ref{chapter:anchoring_data_into_the_blockchain} and provides a game theory based mechanism using multi-party computation to support the negotiation.
\end{itemize}

%TODO: good blog with overview for into? https://ftalphaville.ft.com/2016/04/29/2160502/decentralised-courts-and-blockchains/

\section{Contributions to Science}
The main contribution to science of this thesis is the design of a novel framework that allows for online dispute resolution using a blockchain instead of a third party service as well as combining the field of negotiation theory with multi party computation to solve the satisfiability problem required to find solutions to a dispute in a privacy preserving way without a third party. To the best of our knowledge this has not been attempted before and is novel research.

This work also contributes to the domain of online blockchain based notaries by implementing a datastore service as described in \ref{sec:disclosure_anchor_data} that anchors each document stored into the blockchain, which will later on be open sourced on GitHub.

\chapter{Background and Literature Review}
\label{chapter:background_and_literature}
This chapter details technologies used during development of this project as well as cryptographic and theoretical work relevant to this dissertation in section \ref{sec:background} and investigates similar research in section \ref{sec:literature_review}.

\section{Background} \label{sec:background}
This section investigates technologies used for as well as relevant to this work.

\subsection{Software development methodology}
The work for this project was subdivided into three stand-alone components that can be considered milestones in an agile setting. The three phases were anchoring data into the blockchain following the chainpoint standard \cite{chainpoint:vaughan}, a system that allows two parties to disclose documents to each other using the blockchain anchoring service implemented in phase one and a platform that allows people to start a dispute. All the evidence and interactions will be held in an immutable ledger on a blockchain to ensure that neither the evidence nor the claims can be tampered with and finally an automated system that takes into account the claims as well as the evidence to suggest an ideal resolution to all involved parties. 
Initally Atlassian Jira was used as a project management platform, on which the roadmap was outlined as high level stories. As the team fell apart and there was only one person working on it the software methodology Scrum as defined by the agile manifesto was only loosely followed. 

\subsection{Source control}
The Git source control facility hosted on the Atlassian Bitbucket infrastructure was used as the version control tool throughout the development process. The project was hosted as a private repository with access to the code granted to members of the original team.

\subsection{Programming languages}
%TODO: probably rewrite saying nodejs jada jada
For the prototype Python 3 was chosen as the main programming language because of it's flexibility and vast module ecosystem that makes prototyping very fast. In addition to the core language features, the Python module repository provides a multitude of blockchain libraries that create abstractions over the typically low level native APIs. Because of their popularity, the vast community support and the availability of Python modules Bitcoin, detailed in section \ref{sec:background_bitcoin} and Ethereum, detailed in section \ref{sec:background_ethereum} were chosen.

\subsection{Public key cryptography}
Public key cryptography, sometimes called asymmetric cryptography, is a system which makes use of two distinct keys, a public and a private key. The public key, $K$, can be widely distributed while the private key, $K^{-1}$ must be kept private, as the names suggest. These systems depend on mathematical properties that both keys can be generated easily, but it's computationally intractable to compute the private key, knowing only the public key and encrypted messages $\{m\}_K$. Additionally it is computationally not feasibly to compute $K^{-1}$ or $m$ knowing $\{m\}_K$. Formally, the public key cryptography interface can be defined as: \cite{BKarp}
\begin{itemize}
    \item{Encrypt: } $E_p(K, m) \rightarrow \{m\}_K$
    \item{Decrypt: } $D_p(K^{-1}, \{m\}) \rightarrow m$
    \item{Sign: }    $S(K^{-1}, m) \rightarrow \{m\}_{K^{-1}}$
    \item{Verify: }  $V(K^{-1}, \{m\}_{K^{-1}}, m) \rightarrow \{true, false\}$
\end{itemize}

While the most popular variants of public key cryptography are the well known RSA and DSA algorithms, as detailed in \cite{RSA:1978:MOD:359340.359342} and \cite{Kerry13fipspub}, elliptic curve cryptography has become more popular in recent years and is the technology used in Bitcoin as well as Ethereum. 

\subsection{Symmetric key cryptography}
Symmetric key cryptography as opposed to asymmetric cryptography is a family of algorithms that use the same key $K$ for encryption as well as decryption. While there exists the drawback of involved parties having to share the secret securely, symmetric algorithms typically are more efficient than asymmetric ones \cite{BKarp}. Formally, symmetric key cryptography can be defined as:
\begin{itemize}
    \item{Encrypt: } $E_s(K, m) \rightarrow c$
    \item{Decrypt: } $D_s(K, c) \rightarrow m$
\end{itemize}
Symmetric key algorithms are usually used in stream- or block ciphers for use in secure communication channels like SSL/TLS. In the cryptocurrency domain they typically aren't used.

\subsection{Cryptographic hash functions}
Bitcoin, described in section \ref{sec:background_bitcoin} as well as Ethereum, described in section \ref{sec:background_ethereum}, at the time of this writing use cryptographic hash functions, SHA-256 to be precise, for the identification of blocks etc. A cryptographic hash function $H$ is a function that takes a plain text $m$ as input and produces an alphanumeric output of fixed length $y = H(m)$. Ideal hash functions should have the following properties \cite{BKarp} \cite{wiki:cryptographic_hash_fn}:
\begin{itemize}
    \item{Calculating $H(x)$ is computationally easy}
    \item{$H()$ is preimage resistant: } \\ It is computationally infeasible to find $m$ given $y$ and $H$
    \item{$H()$ is second-preimage resistant: } \\ It is computationally infeasible to find $m' \mid y=H(m')=H(m)$ given $y$
\end{itemize}
Because of these properties, cryptographic hash functions are widely used in blockchains and crypto currencies.

\subsection{Elliptic Curve Cryptography overview} \label{sec:background_elliptic_curve}
The main advantage of elliptic curve cryptography is that in order to achieve the same level of crypographic security as alternative systems like RSA or DSA, shorter keys can be used due to the fact that there doesn't exist a known sub-exponential algorithm to solve the discrete logarithm problem. This leads to more efficient public key algorithms. \cite{EllipticCurveOverview} \cite{Araki1998} 

Formally, an elliptic curve defined over a finite field is represented by all points that satisfy the equation:
\begin{equation}
    y^2 = x^3 + ax + b
\end{equation}
In order to be secure, the curves chosen must satifsy several criteria and choosing the parameters poorly can result in an insecure curve that can easily be hacked. Bitcoin as well as Ethereum use the curve secp256k1 with $a = 0$ and $b = 7$ that is chosen for it's computational convenience and typically results in $\approx 30\%$ faster computation. For a more detailed overview and the maths the reader is referred to \cite{smart2003cryptography}.

\subsection{Bitcoin} \label{sec:background_bitcoin}
It is hard, if not impossible to understate the impact the invention of Bitcoin had on the world. Not only has it entirely re-invented how people view a currency, but also introduced blockchain as a technology, without which none of this work would be possible. Bitcoin was designed as a decentralised currency, i.e. a currency controlled by the public without a central authority. The main problem it solves is the so called double spending problem, where in theory, the same bitcoin could be spent multiple times without the payee being aware of it. This is solved by timestamping transactions into an immutable distributed ledger, which is realised as an ongoing chain of hash-based proof-of-work. From a technical standpoint, bitcoin can be viewed as a state transition system, operating on a state $\Btcstate$ defined as:
\begin{equation}
    \Btcstate := (\Btcinput, \Btcoutput)
\end{equation}
where $\Btcinput$ is the set of transaction inputs and $\Btcoutput$ is the set of transaction outputs as detailed in the next section.

\subsubsection{Transactions}
A Bitcoin transaction, defines a transfer of ownership, by consuming one or more unused outputs (UTXO \cite{bitcoin_wiki:utxo}) of a previous transaction, and generating new outputs that the receipient can then again consume and so forth. From a technical perspective, a transaction can be seen as a state transfer function $\Btcstate' := \delta_{tx}(\Btcstate, \Btcinput_{tx}, \Btcoutput_{tx})$. where $\Btcinput_{tx}$ defines the inputs of a transaction and $\Btcoutput_{tx}$ the outputs of this transaction. The function semantics are defined to be:
\begin{equation}
    \delta_{tx}((\Btcinput, \Btcoutput), \Btcinput_{tx}, \Btcoutput_{tx}) := \begin{cases}
        (\Btcinput \cup \Btcinput_{tx}, \Btcoutput \cup \Btcoutput_{tx}) & if \Btcinput_{tx} \subseteq \Btcoutput \setminus \Btcinput \\
        (\Btcinput, \Btcoutput) & if \Btcinput_{tx} \not\subseteq \Btcoutput \setminus \Btcinput
    \end{cases}
\end{equation}
This means that only transactions, that reference available outputs are considered valid transactions and are hence added to the state. This is an oversimplification of how transactions work and are executed, and it is worth pointing out that a UTXO can only be consumed if the transaction contains proof that it was issued by the holder of the private key associated with the public key in the output. So called coinbase transactions\footnote{Transactions that generate coins without inputs} are also left out, the curious reader is encouraged to read the bitcoin developer wiki on transactions \cite{bitcoin_wiki:transactions}.

\subsubsection{Timestamping, proof-of-work and mining}
The main problem bitcoin solves is the so called double-spending problem, where two transactions could be spending the same inputs without the payee noticing. To resolve this, it is imperative that there exists a total ordering of transactions, such that all nodes eventually reach the same state $\Btcstate$.

The solution bitcoin proposes is the so-called blockchain, an ever growing history of blocks containing transactions. A block can loosely be defined as:
\begin{equation}
    B_t := ((H(B_{t-1}), H(\nonce + T)), \nonce, T)
\end{equation}
where $H(B_{t-1})$ is the previous block's hash, $H(\nonce + T)$ is the current block's hash, computed from a random nonce $\nonce$ and the transactions contained in this block $T$. This list of transaction containing blocks defines the order in which transactions have occurred. In case that multiple nodes create blocks simultaneously and create a fork on the chain, one fork will eventually outgrow the other and be accepted as the only true history wiping the shorter branch from existence.

In this simplistic view, it would be easy for an attacker to create a chain that is longer than the existing chain and hence invalidate existing transactions, this problem is solved with the so-called proof-of-work scheme.

\subsubsection{Proof of Work} \label{sec:background_bitcoin:proof_of_work}
As defined in the previous section, each block contains $H(\nonce + T)$, a hash of the nonce and transactions contained in the block. Proof of work is simply the operation of finding $H(\nonce + T) < threshold$, which due to the underlying cryptographic properties can only be computed by sequentially incrementing the nonce $\nonce$ and trying every possible nonce until a valid hash code is produced. In bitcoin the threshold varies and is re-adjusted every 2016 blocks to have an average time of 10 minutes for a new block to be generated. This essentialy means that the longer the chain grows, the harder it is to re-generate it, and it can only be outgrown by a malicious attacker if they control a majority of the networks CPU power.

Because of this proof-of-work scheme, creating a block costs significant CPU time and hence electricity. To incentivise people to put in the investment as well as time, the creator of a new block is rewarded with some bitcoins\footnote{This is somewhat similar to gold miners digging for gold and is hence called mining.}\footnote{The amount decreases over time as there is an upper limit on the number of bitcoins thatcan be in circulation.} as well as any transaction fees included in the transaction included in the block. \cite{bitcoin:satoshi}

\subsubsection{Multiple In- and outputs} \label{sec:background_bitcoin:multiple_in_out}
Because of the way bitcoins are transferred, a person controlling 1 bitcoin, may control this one coin as 5 distinct utxos, each worth .2 bitcoins. In order to pay someone 1 bitcoin, the transaction needs to contain all these outputs to transfer a total of 1 bitcoin. Similarly, if a person controls 1 BTC in one single UTXO and they wish to spend 0.5 BTC, then consuming that input and creating a new output worth .5 BTC results in .5 BTC being spent as transaction fees that go to the person mining the block this transaction is in. This is in most cases not desirable, and in order to regain ownership of the remaining .5 BTC, a second output must be added to the transaction transferring the change back to oneself. The difference in amount between all inputs and outputs is considered the transaction fee and can be set arbitrarily, if it is too low however, miners may refuse to include the transaction in their blocks. \cite{bitcoin:satoshi}


\subsection{Ethereum} \label{sec:background_ethereum}
At the time of writing, Ethereum is the second larges crypto currency in the world. Despite this, it was not designed as such, but rather a platform for secure distributed computation, sometimes referred to as world computer and is based on the principles pioneered by Satoshi Nakamotos Bitcoin. \cite{ethereum:vitalik_buterin} \cite{ethereum:gavin_wood}

\subsubsection{Accounts}
As opposed to Bitcoin, where the state is made up of inputs and outputs, the state in Ethereum is made up of accounts that have a 20 byte account ID, an amount of Ether, the name of the cryptographic tokens forming the value system, an optional contract code and data storage. In Ethereum there exist two types of accounts, privately owned accounts controlled with a private key and contract accounts controlled via the contract code stored in the account. \cite{ethereum:vitalik_buterin} \cite{ethereum:gavin_wood}

\subsubsection{Messages and Transactions}
Similarly to Bitcoin, Ethereum can loosely be interpreted as a state machine where transactions and messages are used as state transfer functions. The difference between Messages and Transactions is that the former are internally generated, i.e. by a contract, whereas the latter are sent into the network from an external actor. For a more detailed explanation of the differences and internal details refer to \cite{ethereum:gavin_wood}.

When a transactin from an external actor is sent, the Ethereum network picks it up and uses the optional data provided by it in it's execution. Similarly to Bitcoins pubkey scripts, Ethereum has an internal scripting language that is used for contracts and implements it's own turing complete VM that allows execution of arbitrary code on the network. This obviously poses the risk of contract executions taking too long and hence consuming too many resources or even running into infinite loops essentially bringing nodes in the network down. To address this issue, the concept of \texttt{GAS} and \texttt{GASPRICE} was introduced. Every computational step essentially costs 1 \texttt{GAS} with a few exceptions costing more and \texttt{GASPRICE} defines the price of 1 \texttt{GAS}. This mechanism in combination with a maximum gas price guarantees that no computation can run infinitely long and hence eliminates the risk of DOS attacks using expensive computations.

\subsubsection{Smart Contracts}
Smart contracts are code hosted in an account on the Ethereum network. For contracts to be useful, Ethereum has a stack based VM with an infinitely growable memory and a storage that is turing complete. Storage - which is a key/value based store - as opposed to the stack and memory that reset after each execution, storage persists for the long term. For detailed specifications on the EVM, please refer to \cite{ethereum:gavin_wood}.

\subsubsection{Blockchain and Mining}
The Blockchain in Ethereum is very similar to the one used in Bitcoin, with only a few differences. Blocks contain not only the transactions, i.e. state transfer functions, but also the latest state of the system wich means that it is not necessary to download the whole blockchain to mine a block, but only the latest. In reality this would be quite wasteful and the state is hence stored in a patricia tree where the latest block only contains the changes and includes references to unchanged elements in earlier blocks. 

A miner in the network, similarly to Bitcoin, validates all transactions and contract executions and generates a new block that is then published to the network. Because the time between blocks in Ethereum is a lot smaller than in Bitcoin forks of the blockchain happen more regularly. To avoid wasting the computational expense that went into mining these duplicated blocks, they are included as so called uncle blocks in future blocks and miners of these are awarded a portion of the transaction fees. For more details please refer to \cite{ethereum:gavin_wood}.

\subsection{Chainpoint} \label{sec:literature_chainpoint}
Chainpoint defines a standard for prooving existence of data using blockchains. The idea was pioneered by M. Aroz \cite{proof_of_existence} and is realised by anchoring a cryptographic digest of the document into the public bitcoin blockchain. Chainpoint expanded upon that and defined an open standard on top of the initial proof of existence idea to reduce cost and improve scalability.
Blockchains, by design, have a limited transaction throughput and transactions cost money as well as take time to be confirmed, see chapter \ref{chapter:properties_of_blockchains} for more information. While fees can be optional, they incentivise miners to accept a transaction and add it into a block. In order to reduce the overhead of anchoring multiple documents, chainpoint is a standard that uses a merkle tree for all documents whose root is then anchored instead of a hash of each document itself. The Chainpoint receipt then contains the merkle root, the merkle proof, the target hash and the id of the transaction used for anchoring.

The standard aims to be blockchain agnostic and defines receipts for multiple blockchains, which at the time of writing are only Bitcoin and Ethereum. It defines how to construct merkle trees with an even as well as uneven number of leaf nodes and a JSON-LD\footnote{https://json-ld.org/} schema\footnote{https://w3id.org/chainpoint/v2} for the structure of the receipt. Section \ref{chapter:anchoring_data_into_the_blockchain} details how this standard is used in this work.

\subsection{Alternative Dispute Resolution}
When disputes between two parties arise, for example because the customer is not satisfied with the quality of a purchased product and dealing with the trader directly did not lead to a satisfactory resolution, then quite often it is preferable to involve a neutral third party and start one of the many alternative dispute resolution techniques instead of going to court directly. Some of the advantages of alternative dispute resolution methods are that they are generally a lot cheaper, and don't involve the complications that come with having to go to court. \cite{adr_overview:findlaw}

While there do exist countless variants for ADR, the most popular variants are conciliation or mediation, adjudication and arbitration \cite{using_adr:citizensadvice}.

\subsubsection{Mediation and conciliation}
Mediation is a popular technique for disputes and usually takes place before arbitration. It includes an impartial intermediary that helps the involved to find a mutually acceptable settlement. The solution is not binding and the effectiveness of mediation hence depends on the willingness of all involved parties to come to a mutually beneficial settlement.

Conciliation typically happens earlier than mediation and focuses on opening communication channels as well as identifying points of mutual agreement. Mediation on the other hand focuses on finding weaknesses in the involved parties arguments and proposing possible mutually acceptable solutions.

Both methods are completely voluntary and the intermediary does not decide on a resolution, but helps the parties to find one themselves. It can be the case that the mediator or conciliator is not impartial and their view may hence not be independent. \cite{using_adr:citizensadvice}

\subsubsection{Adjudication}
Adjudication is a less formal variant of arbitration where an impartial Adjudicator looks at all the written evidence the parties provide and makes a decision. The adjudicator is usually an expert in the field, his decision however is not binding and the problem can be taken to court if the involved parties do not agree with the decision made. \cite{using_adr:citizensadvice}

\subsubsection{Arbitration}
Arbitration is very similar to litigation in the sense that disputants present their arguments to a neutral third party that then decides on a final and imposable resolution that is enforceable in a court of law. Both parties have to agree upfront that they will abide to the decision made by the intermediary.
The differences to civil litigation are that the involved parties can choose the third party themselves whereas in the judicial system there is typically very little to no control over who will preside as the judge. Another difference is that arbitration is often chosen as a means to start negotiations before an actual dispute materializes whereas the judicial system usually is preferred afterwards. \cite{adr_overview:findlaw}

Arbitration comes in two variants, private- and judicial arbitration. Private Arbitration, the more popular variant, includes two parties who contractually agree to adhere to the decision made by the arbitrator which usually is a private person chosen by all involved parties upfront. The arbitrators decision is binding. Judicial arbitration is usually court imposed and the decision made by the arbitrator is non-binding, meaning that any party dissatisfied with the decision has the right to formally appeal and take the claim to court. Typically this has to be done within a certain time limit decided upon by the court and if this is exceeded the decision becomes binding just as with private arbitration.

\subsubsection{Remarks}
ADR techniques have gained popularity in recent years and there are countless variants of the outlined methods. In all ADR techniques facilitating negotiations between the involved parties plays an important role, but it is important to note that they are not the right choice for all legal disputes. One major factor is that parties involved in ADR usually waive their right to object to evidence that might be inadmissible in a court of law - one example of this is hearsay.

\section{Literature Review and Related Work} \label{sec:literature_review}
This section investigates existing services and research that is relevant to the area of blockchain based alternative dispute resolution.

\subsection{Blockchain based notary-like services}
In legal disputes, it is imperative, that guarantees about the existence of documents can be made as well as the ability to proof interactions between parties. In ADR this would typically be a neutral third party, which has, amongst others, notary-like roles.

While the range of services provided by notaries is by far not restricted to the ones mentioned here, for the purpose of this work only two are required. Witnessing and certifying the validity of signatures on documents as well as certifying the authenticity of the document itself. \cite{notary:does_blockchain_notary_work}

The blockchain can satisfy both of these requirements, using arbitrary data embedded into transactions as detailed in chapter \ref{chapter:anchoring_data_into_the_blockchain}, it can be proven that a document existed at a given point in time, and the person that put the document there can proof that it was them putting it there using public/private key cryptography.

There do exist a variety of online services attempting to replace notaries using a public blockchain, some popular ones are the following, as taken from \cite{notary:does_blockchain_notary_work}:

\begin{itemize}
    \item{\textbf{Bitproof:}} Created by 18 year old Louison Dumont. The process requires users to record a video of themselves though as part of the process.
    \item{\textbf{BlockSign:}} Must be a pdf but is a free service.
    \item{\textbf{ProveBit:}} Links to a github code repository.
    \item{\textbf{Stampd:}} Simple and effective. Costs 9 cents.
    \item{\textbf{Stampery:}} Not an online service. More enterprise and consultancy focused.
    \item{\textbf{Proof of Existence:}} Same technical process under the hood.     
    \item{\textbf{Tierion:}} Online blockchain based data store. The implementation developed in the course of this work is based on this services specification as detailed in chapter \ref{chapter:anchoring_data_into_the_blockchain}
\end{itemize}

While these services come close to providing some of the services of a notary, one major shortcoming is that it is not possible to proof that it was a certain person putting the document there. Stampery propose to use NameCoin\footnote{\url{https://namecoin.org}} to assign an identity to a document, this however has not been implemented or tested yet, and there is no guarantee that a fraudulent attacker couldn't register a fake name to impersonate someone else \cite{notary:does_blockchain_notary_work} \cite{notary:stampery_medium}.

\subsection{Online dispute Resolution and Negotiation support}
Since the advent of online commerce, online dispute resolution tools have become more and more important and popular. One of the largest is Ebay settling disputes between buyers and sellers \cite{deffains2005efficiency}. According to \cite{Lodder:ORD_system_design} there are three types of ODR concepts, mediation done exclusively online, mediation of e-commerce disputes and mediation using electronic media like video conferencing. This work focuses exclusively on the first part, ADR done exclusively online.

In general ODR systems can be seen as negotiation support tools that are either game theory based, heuristic based or argumentation based \cite{Rahwan:2003:AN:1030328.1030332} and existing online services for ADR can always be classified into one or more of these categories. Some examples include SmartSettle, which use a game theoretic approach by defining a collaborative bargaining game \cite{thiessen2003mobile} or DiaLaw, which uses an argumentation based dialoge that supports freetext interactions between parties, or Family-Winner \cite{Bellucci:2004:IAI:1032651.1033678}, which combines the dialogue based approach of DiaLaw with a game theoretic approach to dividing issues using trade-off maps.

In \cite{Wooldridge:2000:LN:3006433.3006516}, Parsons and Wooldridge formalise a logic-based language for use in negotiation between agents as well as a meta-language used to define a dispute itself, which is the basis of the formalism used in this paper. Ragone et al \cite{Ragone:2006:PAO:1124566.1124569} propose a pareto optimal framework for one-shot multi issue negotaition between opposing parties. They formally define the process and protocol using propositional logic and illustrate how their formulation can be applied to a real scenario. While the general formulation influenced the dispute protocol proposed in chapter \ref{chapter:dispute}, it is not readily applicable to this work as it involves a third party that has a clear view of the demand and supply sets $D$ and $S$ as well as the reservation sets $R_d$ and $R_s$.

In \cite{DBLP:journals:corr:ZhangZ14a}, Zhang et al introduce an axiomatic model for an ordinal bargaining problem and introduce a formalism for specifying the problem mathematically using propositional logic. While the model is only developed for a discrete domain, they devise a mechanism to discretize the continuous problem and shows that the solution is close to the Nash Equilibrium. Interesingly an ordinal approach is chosen over a numerical approach to define the utility as their belief is that it is easier to decide the relative importance of issues rather than assigning absolute values to it.

In \cite{fatima2005comparative} a comparison between evolutionary and game-theoretic approches to negotiation is studied. They argue that while the theoretical approach to bargaining including perfectly rational players works well, boundedly rationl players representing real parties better find the best strategy by trial and error. They argue that the genetic approach to learning a strategy in reality will most likely be prohibitively expensive and game-theoretic approaches may be easier and more feasible to implement.

\subsection{Secure multi-party computation} \label{sec:background_linear_program}
Multi-party computation, or MPC, is a field of applied cryptography where multiple parties attempt to jointly compute a function while learning only the functions output without gaining any knowledge about the other parties inputs. This is a well studied field with differences between the two-party and multi-party case. \cite{goldreich1998secure}

In \cite{du2001secure}, Du et al provide an extensive review of real-life MPC problems and their solutions as well as open problems based on Yao's garbled circuit protocol \cite{yao1982protocols} as well as transformation based approaches. In the garbled circuit setup, a function is converted into a boolean circuit, where each of the gates is obfuscated and shared between parties using oblivious transfer. This approach is not feasible for the ADR system designed in this work as it requires communication between parties during the function evaluation which is not a property this system is supposed to have.

In a more specific setting, linear programs to be precise, it is possible to use a transformation-based approach to solve the problem without sharing the actual constraints. Mangasarin \cite{Mangasarian2012} proposes a simple reformulation of a linear program using a privately held transformation matrix, which makes use of the property that the feasible region defined by the constraints is not changed by a linear transformation. The approach works by transforming the linear program:
\begin{equation}
    \min_{x\in X}c^\prime x \;\textrm{where}\; X = \{x \mid Ax=b, x\geq0\}.
\end{equation}
into an equivalent privacy preserving linear program
\begin{equation}
    \min_{y\in Y}c^\prime y \;\textrm{where}\; Y = \{y \mid BAy=Bb, y\geq0\}
\end{equation}
which is "secure" as it does not expose any of the private data $A$. In the context of this work, a linear program with constraints of the form $Ax\leq b$ is required which can not readily be solved using the same technique, instead the approach taken by Wei Li et al \cite{Li2013} and analysed in \cite{vaidya2009privacy} can be used. The approach is based on transforming inequality constraints into equality constraints through the introduction of slack variables. These slack variables are then transformed using another privately held matrix $D$ resulting in the linear program where $x_s$ and $y_s$ denotes the slack variables.
\begin{equation}
    \min_{x\in X}c^\prime x \;\textrm{where}\; X = \{x \mid Ax + Dx_s = b, x\geq0, x_s\geq0\}.
\end{equation}
and the equivalend privacy preserving linear program
\begin{equation}
    \min_{y\in Y}c^\prime y \;\textrm{where}\; Y = \{y \mid BAy + BDy_s = Bb, y\geq0, y_s\geq0\}.
\end{equation}


\chapter{Properties of blockchains}
\label{chapter:properties_of_blockchains}
In this chapter a summary of some important properties and guarantees blockchains, Bitcoin and Ethereum in this case, can provide. At the time of writing they are the two most popular cryto currencies and while both differ significantly in the way their underlying blockchain is built and maintained, they both suffer from the same basic problems. 

\section{Ellyptic curve cryptography}
Bitcoin as well as Ethereum use elliptic curve signatures, ECDSA, for signing and verifying of transactions on the network. The main reason behind ECC over RSA is that the same safety guarantees can be providing while using significantly shorter keys. Mathematically speaking, ECC signatures are currently very safe, but there do exist known attacks to compute a private key, one of which is Pollards rho strategy. The curve secp256k1, currently used in Bitcoin and Ethereum has no known mathematical flaws, but there are reports of a successfully extracted private key using a side-channeling attack. \cite{EllipticCurveOverview} 
In the ADR context the user does not directly interact with the blockchain as they use a blockchain agnostic abstraction instead. If the private key for the underlying blockchain account shouldget leaked, this would most likely result in a service outage as the attackers could drain the funds of the wallet making it impossible to anchor any more data.

\section{Double spending problem and confirmations}
While there are many use cases beyond it, the main problem blockchains address is the double spending problem. In the original Bitcoin paper it is defined as the problem that a single coin could be spent multiple times, which is a property that must not be possible in a crypto currency. This problem is addressed using the blockchain as a unique history of transactions that can be verified by every node in the network traversing the history from the beginning to the transaction. One of the problem is when multiple miners create a block at the same time, causing a so-called fork in the blockchain. In this case both blocks could contain inconsistent transactions that double spend a single coin. To this extent, confirmations are defined as the number of blocks anchored after the block containing a transaction such that it can be guaranteed that the transaction is not anchored in a temporary fork and will become void later in time. Depending on the importance of the confirmation, typically based on the amount of money transferred, confirmation times can vary between 10 minutes and 1 day (144 blocks). Transactions with 0 confirmations are fairly easily reversible as mining ASICs\footnote{Application specific integrated circuits optimised for mining.} can be temporarily overclocked to increase their hashrate and potentially overpower the network enough to create a longer alternative history.

Because of the design of the anchoring service, where funds are transferred back to oneself this issue is not particularly relevant. There is no need to wait for a large number of confirmations to make sure the transaction is and will remain valid as there is no real benefit from tricking oneself.


\section{Coping with Moore's law}
All security properties of a blockchain depend on the fact that mining a new block is computationally expensive. Moore's law loosely translates to computing power doubling every two years which means that mining a new block will become faster and faster with time, resulting in miners joining with more recent equipment potentially gaining a significant advantage. If the time it takes to generate a new block is too small, then eventually long forks in the chain will be the norm and transaction confirmation a problem. A related issue is that as more and more miners join the network, the computing power of the network increases and hence the time between blocks would decrease. To eliminate this problem, Bitcoin as well as Ethereum define a variable difficulty parameter, that keeps getting adjusted to keep the time between blocks more or less constant. In Bitcoin, every 2016 blocks the difficulty is adjusted to keep an average of 10 Minutes between blocks\cite{bitcoin_wiki:difficulty}, whereas in Ethereum the average block time is set to be between 10 and 19 seconds and adjustment takes place every time the difference between a block and it's parent is $<10$ or $>20$ seconds\cite{ethereum_wiki:homestead}. This blocktime is often called the networks heartbeat and guarantees that there won't be any forks maintained for too long such that double-spending of coins would be possible - unless the adversary holds more than $51\%$ of the networks CPU power.

The problem with this approach is that it takes time for a transaction to be included in a block, or otherwise a transaction appearing in a fork that becomes void such that it will have to be included in a new block and so forth. The chainpoint standard includes the transaction identifier and has no notion of block or confirmations which leaves the ADR user with the need to manually confirm that their anchored data has been confirmed as it otherwise could wipe from existence.


\section{The 51\% attack}
Because of the way Bitcoin and Ethereum are designed, it is possible for forks to happen, whenever multiple miners mine a block simultaneously for the same parent. This means that there exist two possible histories of transactions which would theoretically allow a person to double spend a coin or revert their transactions after the payee believes they have received the funds. If a malicious miner holds more than 51\% of the CPU power of the whole network, then they will be able to outpace the rest of the network by mining more blocks than everybody else combined. In this scenario, the adversary can rewrite historic transactions by simply creating a fork of the network starting from a history they like. Once they have grown their own fork longer than the "real" history of the network, all nodes in the system will accept the longest chain as the true chain effectively undoing all transactions that have happened on the real chain. While this is not an easy thing to achieve, it needs to be pointed out that mining pools pose such a threat to the current system as they accumulate a significant portion of hashpower.

This is an issue as a malicious adversary could disclose a document to another party and in the case where this adversary holds a majority of the networks hash power they can revert any transaction in the network. This in turn means that they could delete the anchored data of a document and delete the proof of existence in the blockchain.

\section{Forks and implications on security}
In addition to temporary forks on the blockchain that happen regularly, the technology itself needs to evolve to tackle scalability or security issues. Changes in the software, called forks, can have different implications on the protocol and are categorised into the following three types\cite{coindesk:bitcoin_forks}:
\begin{itemize}
    \item\textbf{Soft Fork:} A soft fork is a backwards compatible protocol change, e.g. the reduction of block sizes from 1MB to 500KB. In this case, nodes running the old software will consider blocks created by the new software as valid, but nodes running the new software will reject blocks mined by the old one. For this reason, soft forks require a majority of hash power as otherwise the new chain can get overpowered and orphaned by the old nodes.

    \item\textbf{User activated Soft Fork:} In contrast to standard soft forks, this is the notion of a change that is championed by users running full nodes rather than the developers. In order for this to succeed, the initiators of the idea will need to gather a majority of hash power for the change to get implemented and adopted.

    \item\textbf{Hard Fork:} In contrast to a soft fork, a hard fork is not backwards compatible. Old nodes would reject blocks mined by nodes running the new version of the software and are forced to update to the later version to continue mining. If a significant portion of the network decides against the change, then two separate chains are created as has happened with Ethereum and Ethereum Classic or Bitcoin and Bitcoin Cash.
\end{itemize}
Most forks are and will be soft forks as breaking the protocol is very risky and it usually won't be in the interest of the community to create two separate streams. The main problem with forks is that as it becomes more lucrative to either move to the new chain, or remain on the old chain, one of them could potentially be drained of miners essentially leaving the network open to attacks. In case of the ADR anchoring system it is important to always use a public chain with a large number of miners in the network.

\section{Mining and the tragedy of the commons}
In economic theory, the tragedy of the commons \cite{wikipedia:tragedy_of_the_commons} is a situation where individuals acting independently in their self-interest behave contrary to the common goal of the community by depleting the resource through their collective action. This phenomenon can hypothetically occur in Bitcoin in the far future when the block reward goes near zero. Bitcoin defines an upper limit on the number of coins in circulation and reduces the number of coins awarded to each block to do so. This in turn can lead to a situation where mining a block is no longer profitable as miners will include transactions with low fees as the overhead cost is marginal incentivising people to include lower and lower transaction fees. This in turn can make miners move on to different blockchains making 51\% attacks more likely which results in the same issues as described above.

\section{Transaction throughput}
While bitcoin specifies a maximum block size of 1MB, which puts a hard limit on the number of transactions being included in a block, Ethereum specifies a gas limit on blocks. According to \url{https://ethstats.net} the gas limit on 20/08/2017 is roughly $6,700,000$. Without going into too much detail, the smallest possible transaction on bitcoin, which comprises one input and two outputs, one for change and one for the payment, has 226 bytes which results in roughly 7 transactions per second throughput at best. In the case of Ethereum, there is no theoretical limit on the transaction throughput as miners can increase the gas limit per block if the block is filled with transactions. According to \url{https://etherscan.io} the current best transaction throughput is roughly 20 transactions per second. It is important to notice these limitations as anchoring data into the blockchain is direclty influenced by them.

The transaction throughput directly influences the confirmation time of the network, which can be a big issue in disclosing documents. Typically when a proof of existence, or chainpoint receipt is generated it is expected that this is confirmed and forever anchored in the blockchain. There are reports of transaction backlogs on Bitcoin and Ethereum of over a day which potentially can be prohibitive for time sensitive disputes.


\chapter{Disclosure - Blockchain anchoring} \label{chapter:anchoring_data_into_the_blockchain}
In this chapter, first a formal definition for documents and disclosure is designed, then a a state machine design for discovery is formalised\footnote{As defined earlier, the term discovery describes the process of disclosing documents.}. Next the blockchain anchoring service implemented in this work is described and lastly the prototype system for disclosing documents is explained. 

The focus lies on the system to be a generic framework for multiple parties to disclose and inspect documents based on cryptographic proofs and guarantees. In order to minimise the dependencies on any particular blockchain, the definitions all assume no specific underlying blockchain and propose a micro transaction protocol that can be run on top of an existing blockchain without the need for an account with funds to pay transaction fees. Also it is important to note that English law does not formally define the process of discovery for ADR\footnote{http://newsroom.howardkennedy.com/disclosure-of-documents-in-international-arbitration-a-solution-for-globalised-trade}, as opposed to a well defined set of rules for formal litigation. The parties involved in the dispute typically agree on a form of ADR as well as the rules they wish to follow. 

\begin{figure}
    \includegraphics[width=1.0\textwidth]{./figures/adr_workflow.png}
    \caption{ADR Workflow}
    \label{fig:adr_workflow}
\end{figure}

\section{Formalising Disclosure} \label{sec:formalising_disclosure}
There are many different ways to perform disclosure, and depending on the type of ADR as well as the domain of the dispute, financial, civil etc, the process can vary. In civil litigation full disclosure is usually recommended, while in financial disputes the involved parties may choose not to disclose confidential information to the other party, but only to the intermediary. In this chapter we formally define how disclosure can be performed using blockchain technologies without a third party involvement based on the ADR workflow illustrated in figure \ref{fig:adr_workflow}.

Disclosure is merely the claim that a document exists, where the disclosing party has an obligation to produce the document should the other party request inspection of it. This is loosely based on UK civil procedure rules as defined in \cite{justice_gov:civil_procedure_rules}. To perform disclosure without the involvement of a third party, a disclosed document must provide three guarantees:
\begin{enumerate}
    \item{\textbf{Proof of existence:}} It must be possible for any of the involved parties to proof that a document existed at a certain time in the past. \label{itm:disclosure_document_objectives_existence}

    \item{\textbf{Proof of disclosure:}} It must be possible for any involved party to proof that a document was disclosed by another involved party. \label{itm:disclosure_document_objectives_disclosure}

    \item{\textbf{Secrecy against evesdropper:}} Secrecy of the document exchange must be guaranteed, that means that while eavesdroppers may be able to intercept that two parties are communicating, the identity as well as details of the interaction must remain secure. \label{itm:disclosure_document_objectives_evesdrop}

    \item{\textbf{Secrecy of confidential information amongs parties:}} It must be possible to obfuscate confidential information such that the counterparty will only know of it's existence and information that is willingly provided. It must also be possible to later on produce the confidential document in a verifiable manner. \label{itm:disclosure_document_objectives_confidential}

    \item{\textbf{Proof of identity of involved parties:}} It is desirable for each party to have the ability to proof the identity of the party that has disclosed documents for the purpose of possible follow up formal litigation processes. This is briefly investigated in chapter \ref{chapter:key_management}. 
\end{enumerate}
In order to meet the above mentioned objectives while remaining blockchain agnostic, a micro transaction framework is devised that is based on the definitions provided in the following sections:

\subsection{Definition of Document} \label{sec:definition_of_document}
A Document is defined as a composite of the document and cryptographic proofs to meet the objectives set out in the previous section. Formally a document is defined as the quadruple:
\begin{equation}
    \doc := (\keydocowner, \doctitle, x, S(\keydocowner^{-1}, (\keydocowner, \doctitle, x))) \mid x \in \{ E_{\{p,s\}}(\_, \content), \content\}
    \label{eq:disclosure_document}
\end{equation}
It consists of the public key of the disclosing party $\keydocowner$, a freetext title or description of the document $\doctitle$, $x$ which depending on the requirements is either the plaintext content $\content$ or the encrypted contents using either public or private key cryptography with a key of choice $E_{\{p,s\}}(\_, \content)$. The last component is a cryptographic signature using the private key of the disclosing party $\keydocowner^{-1}$ over the triple $(\keydocowner, \doctitle, \content)$.
In this work, documents openly disclosed are sent in plaintext, i.e. $x := m$ and for private documents that shall be withheld from inspection by the other party, symmetric key cryptography with a per-document key is used, i.e. $x := E_s(\keydocument, m)$. While there do exist more sophisticated mechanisms like multi party computation to securely share encrypted data with no one party knowing the full key, this is out of scope and considered future work.

\subsection{Definition of Acknowledgement} \label{sec:definition_of_acknowledgement}
While some ADR methods are private, meaning that nothing that happened in the process can be used outside or in later court cases, there do exist situations where it is desirable that it can be proven that a document was disclosed to a certain party. To this extent an acknowledgement is defined as the triple:
\begin{equation}
    \docack := (\keydocrecipient, \doc, S(\keydocrecipient^{-1}, (\keydocrecipient, \doc))
    \label{eq:disclosure_ack}
\end{equation}
where $\keydocrecipient$ is the public key of the recipient of the document, $\doc$ the document as per equation \ref{eq:disclosure_document}, and $S(\keydocrecipient^{-1}, (\keydocrecipient, \doc)$ a cryptographic signature using the private key $\keydocrecipient^{-1}$ to make proof the validity of the recipient.


\subsection{Definition of Receipt} \label{sec:definition_of_receipt}
A receipt is defined as the Chainpoint receipt generated from anchoring the document $\doc$ or the document acknowledgement $\docack$. To be precise, a cryptographic hash $H(x) \mid x \in \{\doc, \docack\}$ is anchored using the system described in \ref{sec:disclosure_anchor_data}. 
Following this process, there exist two types of ADR receipts, one for the document itself and one for the acknowledgement, formally a receipt is defined as a tuple
\begin{equation}
    \receipt := \begin{cases}
        (\docreceipt, \doc) & \textrm{if receipt for } \doc \\
        (\docackreceipt, \docack) & \textrm{if receipt for }  \docack
    \end{cases}
    \label{eq:disclosure_receipt}
\end{equation}
where $\docreceipt$ is the Chainpoint receipt for the document $\doc$ and $\docackreceipt$ is the Chainpoint receipt for the document receipt acknowledgement $\docack$ generated by the anchoring system. The implemented system does not actually generate above receipt tuple but stores $\doc$ as well as $\docack$ if present in the blockchain as well as their anchoring receipts which can be obtained at any time. Typically involved parties would also back up the documents as well as receipts offline for future reference.

\subsection{Definition of the disclosure protocol}
The disclosure protocol can loosely be defined as a state machine with state
\begin{equation}
    S := \{\Receipt, \Docack, \Doc | \receipt \in \Receipt, \docack \in \Docack, \doc \in \Doc\}
    \label{eq:disclosure_state_machine}
\end{equation}
where $\Receipt$ is the set of all receipts, $\Docack$ the set of all document receipt acknowledgements and $\Doc$ the set of all documents and state transfer functions $\statetransferfunc_{add}$, $\statetransferfunc_{ack}$, $\statetransferfunc_{anchor}$ that modify the state of the system $S_t := \statetransferfunc_x(S_{t-1}, \_) \mid x \in \{add, ack, anchor\}$ and are formally defined as:
\begin{equation}
    \statetransferfunc_{add}(\{\Receipt, \Docack, \Doc\}, \doc) := \begin{cases}
        \{\Receipt, \Docack, \Doc \cup \doc\} & \textrm{if} \doc \not\in \Doc \\
        \{\Receipt, \Docack, \Doc\} & \textrm{if} \doc \in \Doc
    \end{cases}
    \label{eq:disclosure_state_transfer_add}
\end{equation}
\begin{equation}
    \statetransferfunc_{ack}(\{\Receipt, \Docack, \Doc\}, (\doc, \keydocrecipient, \keydocrecipient^{-1})) := \begin{cases}
        \{\Receipt, \Docack \cup \docack, \Doc\} & \textrm{if} \doc \in \Doc \\
        \{\Receipt, \Docack, \Doc\} & \textrm{if} \doc \not \in \Doc
    \end{cases}
    \label{eq:disclosure_state_transfer_ack}
\end{equation}
\begin{equation}
    \{\Receipt \cup \receipt, \Docack, \Doc\} := \statetransferfunc_{anchor}(\{\Receipt, \Docack, \Doc\}, x) \mid x \in \{\doc, \docack\}
    \label{eq:disclosure_state_transfer_anchor}
\end{equation}
Informally, $\statetransferfunc_{add}$ can be seen as preparing the document for anchoring, $\statetransferfunc_{ack}$ as the counter party acknowledging the receipt of the document and $\statetransferfunc_{anchor}$ as the anchoring system embedding the documents cryptographic hash into a transaction and generating a Chainpoint receipt.
The state machine describing the protocol for each document is illustrated in figure \ref{fig:disclosure_state_machine} where acknowledgement is optional depending on the use case. This protocol in combination with above definitions can be used to meet the objectives set in section \ref{sec:formalising_disclosure}, and how this is achieved is described next.

\begin{figure}
    \includegraphics[width=1.0\textwidth]{./figures/disclosure_protocol.png}
    \caption{Disclosure protocol state machine}
    \label{fig:disclosure_state_machine}
\end{figure}

\subsection{Applicability of the protocol to defined objectives}
This section describes how a receipt $\receipt$ can be used to meet the objectives set for the system, in particular:
\begin{enumerate}
    \item{\textbf{Proof of existence:}} The Chainpoint receipts $\docreceipt$ and $\docackreceipt$ contain information about the transaction that contains $H(\doc)$ or $H(\docack)$ and can hence be used to proof that the document and the acknowledgement of it's receipt existed before the said transaction was generated and mined.
    \item{\textbf{Proof of disclosure:}} The document receipt acknowledgement $\docack$ contains a signature of the receiving party, proving that they have received the document $\doc$ included in the acknowledgement. The disclosing party then has the ability to proof that the acknowledgement is for the document provided.
    \item{\textbf{Secrecy against evesdropper:}} Assuming the communication channel between the opposing parties is not secure, then encrypting each document with it's unique, or alternatively a per dispute key provides secrecy against evesdroppers.
    \item{\textbf{Secrecy of confidential information amongst parties:}} As all documents can be encrypted with a secret key, it is easily possible to send a document to the other party while withholding the key, effectively proving that the document exists but not disclosing it's contents.\footnote{Shared key cryptography is a potential improvement to this approach but left for future research.}
    \item{\textbf{Proof of identity of involved parties:}} The outlined protocol provides no guarantees about the identity of parties behind the public keys, this problem is briefly investigated in chapter \ref{chapter:key_management}.
\end{enumerate}


\section{Tierion and the Chainpoint standard}
Tierion is by far not the only provider of blockchain based notary-like services, they are however one of the more sophisticated ones and to the best of our knowledge the only ones to have defined a public standard for blockchain receipts. Because of this standard as well as their popularity and flexible API the decision was made, to base the implementation of this system on their specification.

It is however important to note, that while Tierion as well as the open source library developed in this work do anchor documents into the blockchain, there is no association between the owner of the document and the document itself apart from the data stored in a database. In order to link an entity, or more precisely a public key, to the document anchored in the blockchain, it would be necessary for everyone who wants to anchor data into the blockchain to have their own account on every blockchain that the system integrates with as well as possess sufficient funds to pay for the transaction fees. In times where bitcoin transaction fees surged to ~5\$ this would be a very expensive and wasteful approach.

\section{Anchoring data into the Blockchain} \label{sec:disclosure_anchor_data}
In the first phase of this project, a system was developed that provides data storage capabilities as well as anchoring of all stored data records into a public blockchain. This system is based on the software offering of Tierion\footnote{\url{https://tierion.com}} and mimics their REST API. This system is intended to be eventually provided as an open source version of Tierions software system.

\subsection{Library Design}
Conceptionally, Tierion does two things. It provides a document management facility and a mechanism to anchor these documents as well as arbitrary sha256 hashes into the blockchain. These concepts drove the decision to break the library up into two stand-alone components, a document management part with a REST API as well as an anchoring API detailed in the following sections.

\begin{figure}
    \includegraphics[width=1.0\textwidth]{./figures/tierion_db.png}
    \caption{OpenTierion Database Design}
    \label{fig:tierion_database_design}
\end{figure}

\subsection{Document management Component}
The document management component that is exposed via a REST API equivalent to the one defined by Tierion uses a database to store account data, documents as well as the information necessary to generate Chainpoint receipts. The database design is illustrated in figure \ref{fig:tierion_database_design} and the tables are defined as:

\begin{itemize}
    \item \textbf{account:} Holds information about the users account including login information, an api key and information required for a login token.

    \item \textbf{record:} Records in this context represent a document structured as json. The fields are equivalent to the ones defined by the tierion API.

    \item \textbf{datastore:} A Datastore can be seen as a collection of documents that allows to organize documents and set notifications for when certain actions occur on it.

    \item \textbf{hashitem:} A hashitem is a sha256 hash that is then anchored into the blockchain. It is possible to anchor a sha256 hash directly via a hashitem or anchor a record, where a sha256 hashitem is generated based on it's data.

    \item \textbf{confirmation:} Chainpoint at the time of writing supported two endpoints, Bitcoin and Ethereum. A Confirmation in this context represents information about the transaction the document was anchored in. Multiple confirmations in combination with the HashItem they are associated with hold the information required to build a chainpoint receipt.
\end{itemize}
In addition to the document management exposed to users, the library is designed in a way, such that one account is used per backend - more about backend integration in section \ref{sec:opentierion_backends} - to anchor multiple documents across multiple datastores and users. This is done via a periodic check for document age and the number of documents pending anchoring. Once either of these thresholds, which are configurable in the API are exceeded, all pending documents are put into a merkle tree and this merkle tree's root is then anchored into the blockchain and associated with the documents referenced in it.

\subsection{OpenTierion REST API} \label{sec:opentierion_rest_api}
The Tierion API is split into two separate REST APIs, a so called \texttt{Hash API} and a \texttt{Data API}. As compatibility with Tierion was one of the design goals, this open source implementation exposes an API mimicing this structure. Tables \ref{tab:opentierion_hash_api} and \ref{tab:opentierion_data_api} outline the API and operations supported by it. In addition to these APIs, a user API is exposed such that it is possible to manage user accounts via the API.

The Hash API is based on the specification on \url{https://tierion.com/docs/hashapi} and outlined in table \ref{tab:opentierion_hash_api}. Every operation on the hash API requires an access token to be supplied as the header \texttt{Authorization: Bearer <token>}. Tokens can be generated using the API as described in the specification table. The subscription component of the Tierion API was not implemented as part of this work and is left as a future improvement.
\begin{table}[!htbp]
    \begin{tabularx}{\textwidth}{| l l l X |}
        \hline
        \textbf{REST Endpoint} & \textbf{Type} & \textbf{Required fields} & \textbf{Description} \\
        \hline
        v1/auth/token & POST & username, password & Generates an auth token that is valid for one hour. Response includes the token, expiry time and a refresh token. \\

        v1/auth/refresh & POST & refreshToken & Generates a new auth token without supplying username and password again. \\

        v1/hashitems & POST & hash & Queues the hash provided for anchoring into the blockchains. \\
        \hline
    \end{tabularx}
    \caption{OpenTierion Hash API Spec}
    \label{tab:opentierion_hash_api}
\end{table}

The Data API is based on the specification on \url{https://tierion.com/docs/dataapi} and outlined in table \ref{tab:opentierion_data_api}. Every request to the Data API must include the header following header fields, where the api key can be obtained using the user API specified in table \ref{tab:opentierion_user_api}:
\begin{itemize}
    \item\texttt{X-Username: youremail@address.com}
    \item\texttt{X-Api-Key: YourAPIKeyGoesHere}
\end{itemize}
It is not required to supply auth credentials to create a user, to delete or query user information however it is required to supply the users email as well as the password as HTTP Basic auth credentials.

\begin{table}[!htbp]
    \begin{tabularx}{\textwidth}{| l l X X |}
        \hline
        \textbf{REST Endpoint} & \textbf{Type} & \textbf{Required fields} & \textbf{Description} \\
        \hline
		v1/datastores & GET & None & Retrieve all datastores for the current user \\

        v1/datastores/\textless id\textgreater & GET & None & Retrieve the datastore with the specified ID \\

        v1/datastores & POST & name & Create a new DataStore, please refer to online docs for more details. \\

        v1/datastores/\textless id\textgreater & PUT & None & Update the DataStore with the id specified, only supplied fields will be changed \\

        v1/datastores/\textless id\textgreater & DELETE & None & Delete the DataStore with the id specified. \\

        v1/records?\textless query\textgreater & GET & None & Retrieve records that match the query specified. Please refer to online docs for query syntax \\

        v1/records/\textless id\textgreater & GET & None & Retrieve the record with the ID specified. \\

        v1/record & POST & datastoreId & Create a new record associated with a datastore. All other fields will be treated as fields of the record. \\

        v1/records/\textless id\textgreater & DELETE & None & Delete the record with the id specified. \\

        \hline
    \end{tabularx}
    \caption{OpenTierion Data API Spec}
    \label{tab:opentierion_data_api}
\end{table}

\begin{table}
    \begin{tabularx}{\textwidth}{| l l X X |}
        \hline
        \textbf{REST Endpoint} & \textbf{Type} & \textbf{Required fields} & \textbf{Description} \\
        \hline
        v1/accounts & POST & name, email, full\_name, secret & Creates a new account \\
        v1/accounts/\textless name\textgreater & DELETE & None & Deletes the account \textless name\textgreater, requires HTTP basic auth with email and password  \\
        v1/accounts/\textless name\textgreater & GET & None & Retrieves account information including API key, requires HTTP basic auth with email and password \\
        \hline
    \end{tabularx}
    \caption{OpenTierion User API Spec}
    \label{tab:opentierion_user_api}
\end{table}

\subsection{Blockchain integration Component} \label{sec:opentierion_backends}
While the data management component allows users to create, manage and queue items for anchoring, the Blockchain integration component is required to actually perform the anchoring. When the library is instanciated, the integration component is registered with the data management component, and whenever documents are ready for anchoring due to them having been queued up for too long or the number of pending documents exceeding a configured threshold, this registered callback is called.

The library provides two main integrations, one for Bitcoin and one for Ethereum, detailed below. Each of these integrations is designed to work with a list of services that expose blockchain functionality. In the case of Ethereum two services were implemented, a web3 integration talking to a local Ethereum node as well as an integration with Etherscan\footnote{\url{https://etherscan.io/}} such that it is not required to run a local node. In case of bitcoin, a bitcoind integration was implemented to connect to a locally running node. Anchoring itself works very differently in Bitcoin than it does in Ethereum as detailed below.
\begin{itemize}
    \item \textbf{Bitcoin:} The bitcoin protocol was designed to work for the use-case of running a decentralised currency and it is not readily possible to supply arbitrary data to a transaction. As bitcoin transactions are basically a collection of inputs and outputs, and at least one valid output must be present in the transaction, a way to supply arbitrary data is to create one valid output to send the change back to oneself and additionally create an output with a pubkey script that can never be successfully evaluated and is as such an unspendable output. The pubkey script used for this purpose is called OP\_RETURN\footnote{\url{https://en.bitcoin.it/wiki/OP_RETURN}} and was introduced as a way to effectively burn bitcoins. The signing is done offline with the private key supplied to the integration library. If the private key supplied is a python function, then when a signature is required, the callback is called with the transaction as it's parameter such that integration with a hardware keystore is possible.

    \item \textbf{Ethereum:} As Ethereum was designed with the notion of contract execution via transactions, an Ethereum transaction already contains an arbitrary data field that is typically used to supply function arguments or contracts to the network. For this reason, anchoring an arbitrary hash is as easy as supplying the sha256 Merkle root as data in a transaction. Transactions are built locally and use the account/private key supplied in the library configuration. The private key supplied can either be a private key in which case the transaction will be signed locally using this private key, or a python function that gets called back with the transaction as an argument such that integration with a hardware keystore for security reasons is possible as well. Once the transaction is signed it is sent to the service and subsequently broadcast to the network. The returned transaction ID is then used to generate a Chainpoint receipt. It is worth noting that the account associated with the private key must have enough funds to pay the transaction fees.
\end{itemize}
As already mentioned earlier, the library will be open sources and made available on GitHub with more extensive documentation provided online.

\chapter{Key Management} \label{chapter:key_management}
In this chapter, a few possible approaches to Key Management are outlined as it is a requirement for the system to associate identity with keys. Due to the scope of this project, implementing any of these approaches is left for future research.

Wikipedia \cite{wiki:key_management} defines Key Management to be the management of cryptographic keys in a cryptosystem, including the generation, exchange, storage, use, destruction and replacement of keys on the user level. While this work does not focus on this aspect of the ADR system, it is important for a participant in the dispute to prove that another party has agreed to a certain resolution. As parties are only identified via their public keys, being able to prove that a public key represents a given entity is a requirement for this system. 

\section{Certificate Based Identification}
Certificate Authorities are a well established model used in the SSL standard. In this system there would be a set of trusted authorities that have the absolute trust of all parties in the system to not ever be corrupted and not make mistakes. This way, each public key would be associated with a Certificate signed by the CA, or another trusted party that holds a certificate signed by the CA essentially creating a so-called chain of trust. The main problem in this system is that the CA has to be incorruptible, and there exist plenty examples of CA's that issued invalid certificates in the context of SSL.

\section{Identity-Based Cryptosystems}
Initially proposed by Shamir \cite{shamir1984identity}, Identity-Based Encryption uses arbitraty public keys, allowing for the public key to be e.g. an email address, a phone number or another string identifying the entity behind the key. Using a central, trusted authority, private keys can then be derived from that arbitry string public key. The problem in this setup is that it depends on a central authority holding a private key that must be kept secret. These schemes have the advantage that they don't require a certificate, as the public key itself already acts as such. Boneh and Franklin \cite{boneh2001identity} and Sakai and Kasahara \cite{sakai2003id} propose IBE schemes for elliptic curves which could hence be used with blockchains.

\section{Cryptographically signed biometrics or video}
A different approach to the identity problem would be to require each participating party to record a video tape of themselves stating who they are and whom they represent, which they then cryptographically sign using their private key and share both, the signature as well as the video tape with the counter party. This way, it is possible to proof that the video tape was signed by the entity holding the private key associated with the public key used to verify the signature.

\section{Namecoin}
Namecoin\footnote{\url{https://namecoin.org/}} is a cryptocurrency, more precisely a fork of the bitcoin protocol, that provides a key-value type storage on a blockchain. Using the proof of existence guarantee a blockchain provides, it is possible to register the public key with an identity on the blockchain, essentially providing a globally unique association of the key. While this approach is interesting in it's simplicity, there needs to be some mechanism in place to ensure that the registered information is correct as it cannot be changed.

\section{Estonian e-Residency}
The last alternative outlined in this paper is the Estonian e-Residency. In 2014, Estonia launched an initiative to support electronic residency as a wider initiative to digitise the government. While e-Residency does not equal citizenship and hence does not include the right to enter the country, it does associate Identity with a cryptographic key, which can be used in a similar way to the Certificate-Based system, but with a government instead of a CA issuing these. \cite{estonia:eResidency}

\chapter{Dispute - Negotiation using Logic} \label{chapter:dispute}
In this chapter, the dispute phase as illustrated in figure \ref{fig:adr_workflow} is defined and a formal language as well as protocol that allows two parties to argue a dispute using blockchains instead of a neutral third party is designed. This chapter concludes with a design of a system that can provide negotiation support based on the formalism used and protocol designed.  

After discovery has been completed, and all documents made available, the involved parties enter the dispute phase as illustrated in figure \ref{fig:adr_workflow}. In traditional ODR systems, both parties use a third party service to act as a neutral intermediary that is usually used to keep the utility and constraints specified by either party secret. These systems are typically based on research in the well studief field of multi-agent negotiation. There exist a wide range of approaches and techniques to formulate as well as resolve disputes, Rahwan et al in \cite{Rahwan:2003:AN:1030328.1030332} categorize them as game theoretic, heuristic based and argumentation based. They also point out that neither approach suits all needs and there is no one type that fits all disputes. In this work, a combination of a game theoretic and argumentation based approach is designed. 

The following sections provide a formalism for a dispute using argumentation based approaches from \cite{Lodder:ORD_system_design}, \cite{Bellucci:2004:IAI:1032651.1033678}, \cite{Rahwan:2003:AN:1030328.1030332} as well as game theoretic ones as described in \cite{Susskind:Logic_of_mediating_values}, \cite{Ragone:2006:PAO:1124566.1124569}, \cite{Ragone2008}, \cite{Wooldridge:2000:LN:3006433.3006516}, \cite{Chevaleyre:2005:NOS:1082473.1082518}.

\section{Definition of a Dispute} \label{sec:definition_of_dispute}
Disputes come in a lot of varieties, and it is not possible to define one model that is a perfect fit for all of them, there are however some general assumptions as to how a typical dispute works which are used as basic assumptions for this work. According to \cite{Susskind:Logic_of_mediating_values} a typical dispute follows four logical assumptions which are also consistent with the requirements posed on an ODR system as defined in \cite{Lodder:ORD_system_design} as:
\begin{enumerate}
    \item{disputants know what they want and have a fallback plan, a "Best Alternative To Negotiated Agreement" - BATNA}
    \item{Even if their demands are much higher than the BATNA, they're eager to negotiate a mutually beneficial deal which should be supported by the negotiation tool}
    \item{negotiate on issues and eventually reach a middle ground, that in the ODR setting is typically a solution proposed by the system using compensation/trade-off strategies}
    \item{a binding, written agreement is formalised and signed by all participating parties.}
\end{enumerate}
It is important to note that identifying the BATNA is a hard problem on it's own and is not addressed in this thesis. For the purpose of this work, a dispute is defined as having Documents, Statements, Demands and Offers, as well as utilities that define the importance of demands and offers such that the system can value trade-offs and recommend solutions to the involved parties. In addition to the elements defining a dispute, the following properties are ideally all exhibited by system.
\begin{itemize}

    \item{\textbf{Offline:}} The system should not require both parties to be available at the same time and effectively provide a way to make a statement, demand or offer that can later on be addressed by the other party.

    \item{\textbf{Proof of existence:}} Both parties need to be able to proof that the other party has either specified demands that were met by the other party, or proposed an offer that meets the demand, such that in case of either party attempting further formal litigation, there exists a proof of resolution of the dispute.

    \item{\textbf{Secrecy of utility and preference:}} It usually isn't in the interest of either party that the opposing side knows their utility function. The system should hence provide a way for the utility function to be either fully or partially private while still providing both parties a way to resolve the dispute.

    \item{\textbf{Independence of third party:}} It must be possible for the system and the participants to progress a dispute without the need for a neutral third party.

    \item{\textbf{Possibility of involving a third party:}} It is desirable to be able to involve a third party (Facilitator, Mediator, Arbitrator) in case the dispute comes to a state where no progress is made. The third party should be able to get access to all interactions that have happened between disputing parties.

    \item{\textbf{Incentivise agreement:}} The system should have a mechanism in place that encourages the involved parties to reach a consensus, as otherwise they could benefit from delaying the process indefinitely.

    \item{\textbf{Proof of identity of involved parties:}} Both parties need to be able to proof the identity of the other side in order to legally enforce that they act on the accepted negotiated resolution.

\end{itemize}

\subsection{Formal definition of the dispute framework} \label{sec:formalising_dispute}
A dispute can be seen as a negotiation over issues between two parties and can formally be defined in the sense of a Bargaining Game as pioneered by Nash \cite{Nash:bargaining} and expanded on by Rubenstein \cite{Rubenstein}, that enables the system to find a solution that represents a Nash Equilibrium or is Pareto optimal. This definition uses a propositional logic extended with concrete domains $\Proplang$ as defined by \cite{Ragone2008} as well as borrows from \cite{Lodder:ORD_system_design}, \cite{DBLP:journals:corr:ZhangZ14a}, \cite{Bellucci:2004:IAI:1032651.1033678} and \cite{Hemaissia:2007:MMN:1329125.1329314}.
In this work, parties in a dispute can argue issues traceably using a mechanism similar to statements described in \cite{Bellucci:2004:IAI:1032651.1033678} and use $\Proplang$ to formalise their demands or offers. Demands and offers are made up of two types of issues, propositional atoms $\propatom \in \{true, false\}$ and variables $\propvar \in \Propdom_{\propvar}$ where $\Propdom_{\propvar}$ is the numerical domain associated with the variable. Variables are constrained by their domain and a comparison with a constant. These definitions allow to formalise demands and offers like \texttt{resideWithWife$\wedge$(childSupport$\geq$2500)} representing the demands that the wife wants the children to reside with her and child support payments of at least £2500 per month. Additionally conditional demands like \texttt{houseToWife$\Rightarrow$(childSupport$\leq$1000)} representing the fact that if the family home is given to the wife, then child support payments would be less can be formulated as well. For completeness, formal definitions from \cite{Ragone2008} and \cite{Baader:1991:SIC:1631171.1631239} for the above are provided next.

\begin{itemize}
    \item
        \textbf{Concrete Domains:}\cite{Baader:1991:SIC:1631171.1631239} A concrete domain $\Propdom$ consists of a finite set $\Delta_{\Predicate}(\Propdom)$ of numerical values, and a set of predicates $\Predicate(\Propdom)$ expressing numerical constraints on $\Propdom$.

        Predicates are always binary operators $\Predicate(\Propdom) := \{\geq, \leq, >, <, =, \neq\}$ with their second argument being a constant in the domain $\Delta_{\Predicate}(\Propdom)$, the domain can represent amounts of money, weekdays, colours etc depending on the requirements\cite{Ragone2008}.

    \item
        \textbf{The Language $\Proplang$:}\cite{Ragone2008} Let $\Propatom$ be a set of propositional atoms, and $\Propvar$ a set of pairs $\langle\propvar, \Propdom_{\propvar}\rangle$ each made of a feature name and an associated concrete domain $\Propdom_{\propvar}$, and let $k$ be a value in $\Propdom_{\propvar}$. Then the following formulas are in $\Proplang$:
        \begin{enumerate}
            \item every atom $\propatom \in \Propatom$ is a formula in $\Proplang$
            \item if $\langle \propatom, \Propdom_{\propvar} \rangle \in \Propvar, k \in \Propdom_{\propvar}$, and $c \in \{\geq, \leq, >, <, =, \neq\}$ then $(\propvar ck)$ is a formula in $\Proplang$
            \item if $\psi$ and $\varphi$ are formulas in $\Proplang$ then $\neg\psi$, $\psi \wedge \varphi$ are formulas in $\Proplang$\footnote{Additionally: $\psi \vee \varphi := \neg(\neg\psi\wedge\neg\varphi)$, $\psi\Rightarrow\varphi := \neg\psi\vee\varphi$ and $\psi\Leftrightarrow\varphi := (\psi\Rightarrow\varphi)\wedge(\varphi\Rightarrow\psi)$}
        \end{enumerate}

    \item
        \textbf{Interpretation and Models:}\cite{Ragone2008} An interpretation $\Interpretation$ for $\Proplang$ (denoted as a superscript .$^{\Interpretation}$ on it's arguments) is a function that maps each atom in A into a truth value $\propatom^{\Interpretation} \in \{true, false\}$, each feature name $\propvar$ into a value $\propvar^{\Interpretation} \in \Propdom_{\propvar}$, and assigns truth values to formulas as follows:
        \begin{itemize}
            \item $(\propvar ck)^{\Interpretation} = true$ iff $\propvar^{\Interpretation}$ is true in $\Propdom_{\propvar}$ and false otherwise
            \item $(\neg\psi)^{\Interpretation} = true$ iff $\psi^{\Interpretation} = false$, $(\psi\wedge\varphi)^{\Interpretation} = true$ iff both $\psi^{\Interpretation} = true$ and $\varphi^{\Interpretation} = true$, according to truth tables for propositional connectives.
        \end{itemize}

        The notation $\Interpretation\models\varphi$ denotes the fact that $\Interpretation$ is a model for $\varphi$ meaning that it assigns $true$ to $\varphi$. $\Interpretation$ is said to be a model for a set of formulas if it assigns true to every formula in the set.
\end{itemize}
In addition to the formalisation for issues, parties must be able to provide statements to either back, or respond to issues and demands. For the purpose of this work the notion of a statement, based on \cite{Bellucci:2004:IAI:1032651.1033678}, is defined to allow for traceable communication. Formally there are two types of a statement $\statement \in \Statement$ made by a party $\party \in \Party$ containing freetext $\statementtext$, where $\Statement$ is the set containing all statements and $\Party$ the set containing all $\Numparties$ parties participating in the dispute. The two are defined as:
\begin{equation}
    \statement_a(\party, \statementtext, \alpha) \mid \alpha \not\in \Propvar \cup \Propatom \wedge \alpha \neq \varnothing \wedge \not\exists \statement \colon \statement(x, y, \alpha) \forall x,y
    \label{eq:initial_statement}
\end{equation}
\begin{equation}
    \statement_a(\party, \statementtext, \statement_b) \mid a \neq b \wedge \not\exists \statement \colon \statement(x, y, \statement_b) \forall x,y
    \label{eq:initial_statement_s}
\end{equation}
Using these definitions, it is possible to provide statements based on issues expressed as atoms or variabes as well as statements based on earlier ones and they can be classified as the four distinct types:
\begin{enumerate}
    
    \item\textbf{Issue introducing statement}: A statement, referencing an issue is called an issue introducing statement if $\alpha \not\in \Propvar \cup \Propatom$ and $\alpha$ is a valid atom or variable for $\Proplang$. Issue introducing statements are the only way to introduce new atoms or variables into the languge $\Proplang$, and if the trail of statements concludes with a rejecting concluding statement, all formulas including the atom or variable introduced are rendered invalid and will have to be retracted.
        \begin{equation*}
    \statement_a(\party, \statementtext, \alpha) \mid \alpha \not\in \Propvar \cup \Propatom \wedge \alpha \neq \varnothing \wedge \not\exists \statement \colon \statement(x, y, \alpha) \forall x,y
            \tag{\ref{eq:initial_statement} revisited}
        \end{equation*}

    \item\textbf{Concluding statement}: Statements for the same issue over time form a list providing a track record of what was said. The only way to conclude an argument over an issue is to provide a concluding statement which either accepts the introduction of an issue, or rejects it. It is a requiremen, that the party that has introduced the issue is not allowed to provide a concluding statement defined as:
        \begin{equation}
            \statement_a(\party_i, x, \statement_b(\party_j, \statementtext)) \mid a \neq b, x \in \{\textrm{accept}, \textrm{reject}\}
        \end{equation}


    \item \textbf{Supporting statement:} Supporting statements to prior ones are defined as responses to an earlier statement made by the same party:
        \begin{equation}
            \statement_a(\party_i, \statementtext_a, \statement_a(\party_j, \statementtext_b, \statement_b)) \mid a \neq b \wedge i = j \wedge \not\exists \statement \colon \statement(x, y, \statement_b) \forall x,y
        \end{equation}

    \item \textbf{Responding statement:} Responding statements to prior ones are defined as responses to an earlier statement made by an opposing party:
        \begin{equation}
            \statement_a(\party_i, \statementtext_a, \statement_a(\party_j, \statementtext_b, \statement_b)) \mid a \neq b \wedge i \neq j \wedge \not\exists \statement \colon \statement(x, y, \statement_b) \forall x,y
        \end{equation}

\end{enumerate}
Building on above definitions, it is obvious that there exists a number of unconcluded statements until all issue introducing ones are eventually followed by a concluding statement. This notion is required to formalise an agreement and to this extent a set $\Statement^*$ is introduced for use in the next section and defined as
\begin{equation}
    \Statement^* := \{\statement_a \in \Statement\setminus S_c \mid \not\exists \statement_b \in \Statement \colon \statement_b(x,y,\statement_a)\forall x,y \}
\end{equation}
where $S_c$ represents the set of all concluding statements.


\subsection{Formal definition of Resolution/Agreement} \label{sec:agreement}
A resolution or agreement to a dispute, based on \cite{Ragone2008}, is defined as an interpretation $\Interpretation$ that assigns $true$ to the formulas $\demand$ and $\offer$ representing the demand and offer in combination with an ontology $\Ontology$ represented as a set of formulas in $\Proplang$, describing the domain of the dispute\footnote{An example formula in the ontology could be \texttt{resideWithWife$\Leftrightarrow\neg$resideWithHusband} or \texttt{DiscloseWifeUnfaithfulProof1$\Rightarrow$wifeCheated}}. Formally:
\begin{itemize}
    \item \textbf{Demand:} A demand is a formula $\demand$ in $\Proplang$ such that $\Ontology \cup \{\demand\}$ is satisfiable.
    \item \textbf{Offer:} An offer is a formula $\offer$ in $\Proplang$ such that $\Ontology \cup \{\offer\}$ is satisfiable.
    \item \textbf{Agreement:} A possible resolution to the dispute is defined as the set of all Interpretations $\Deal$ satisfying the demand as well as the offer in combination with the ontology $\{\Interpretation \mid \Interpretation \models \Ontology \cup \{\offer, \demand\}\}$. An agreement is then defined as a deal $\deal \in \Deal$ that both parties accept iff $\Statement^* = \varnothing$
\end{itemize}

\section{Dispute Protocol and Domain Specific Language}
Wooldridge and Parsons \cite{Wooldridge:2000:LN:3006433.3006516} provide a definition of a negotiation meta-language which is an equivalent idea and the basis to the domain specific language, DSL, defined in this chapter and denoted as $\Metalang$. The protocol is designed as a repeatable one-shot negotiation with a reference to previous rounds of the game. It is important to point out that the protocol designed simply allows the two parties to negotiate using a blockchain, but does not provide any success guarantees or support that a third party like a Mediatior would otherwise provide, this is investigated in section \ref{sec:negotiation_support} as negotiation support without a third party.

The DSL has to allow parties to specify they have disclosed documents, formalise the demands or offers, argue for or against those as well as accepting or rejecting a resolution. Valid operations $\metaop \in \Metalang$ are defined in Table \ref{tab:dsl_operations}.

\begin{table}[!htbp]
    \centering
    \begin{tabularx}{\textwidth}{|l X|}
        \hline
        \textbf{Operation} & \textbf{Description} \\
        \hline
        $ref(h)$ & Back reference to a previous document identified by $h$. This is used to validate changes made \\
        $disclose(\party, \receipt)$ & Party $\party$ states they have disclosed a document identified by a receipt $\receipt$ as defined in eq \ref{eq:disclosure_receipt} \\
        $ontology(\party, \Ontology_{\party})$ & Partial ontology $\Ontology_{\party}$ provided by party $\party$. If both parties provide ontologies they are combined as $\Ontology := \bigcup\limits_{\party}\Ontology_{\party}$ which must be satisfiable and additionally ontologies must be valid formulae in $\Proplang$ \\
        $constraint(\party, \varphi)$ & Formula $\varphi$ provided as a constraint by party $\party$. It is allowed to specify multiple constraints but they all must be satisfiable in combination with $\Ontology$ as well as valid formulae in $\Proplang$. Depending on the party, the constraints are either considered demands or offers as defined in section \ref{sec:formalising_dispute} \\
        $state(\party, \statement)$ & Statements $\statement$ as per equations \ref{eq:initial_statement} and \ref{eq:initial_statement_s} made by party $\party$ \\
        $accept(\party, \Interpretation)$ & Indicate that party $\party$ accepts interpretation $\Interpretation$. If both parties accept the same interpretation and $\Statement^* = \varnothing$ then a resolution as defined in section \ref{sec:agreement} is reached. \\
        $withdraw(\party)$ & Indicate that party $\party$ withdraws from the negotiation terminating the ADR process. \\
        \hline
    \end{tabularx}
    \label{tab:dsl_operations}
    \caption{Valid operations of the DSL $\Metalang$}
\end{table}

The dispute protocol defines the interactions between the parties and how the dispute evolves and is split into three phases.

In \textbf{phase 1} a party initiates a dispute by creating a document using operations $\metaop \in \Metalang$ referencing document disclosures and introducing atoms and variables via statements. These are then added to $\Proplang$ and the party can introduce an ontology as well as constraints based on these. When a party has finished building the initial state, the document is cryptographically signed, anchored into the blockchain and made available to the other party.

In \textbf{phase 2} the document representing the current state of the dispute is circulated between the parties which alternatingly expand on it using operations $\metaop$. There are no restrictions as to how a party can expand on the current state as long as they only modify $\metaop$ that belong to them and don't introduce unsatisfiable ontologies or constraints. The aim of this phase is to reach a state where an agreement as defined in section \ref{sec:agreement} can be achieved.

In \textbf{phase 3} parties have already introduced all the issues and constraints they wanted, and if the combined constraints of both parties are satisfiable, then they either both expand on the state by accepting an Interpretation resulting in a mutual agreement or by one party withdrawing resulting in a termination of the ADR process. As all constraints are shared in plain text and hence are known to the other party, they can choose to use a game theoretic approach to finding an ideal interpretation $\Interpretation \models \Ontology \cup \{\demand, \offer\}$. In the case where there does not exist such an interpretation, this dispute concludes with withdrawal and it can be started again with phase 1. In addition it is possible to accept multiple interpretations in which case the dispute concludes as soon as both parties accept the same interpretation.

In order to guarantee validity, consistency and tamper resistance, modifications in phases 2 and 3 always reference the document representing previous state and are cryptographically signed by the party modifying it. In addition, these documents are shared by anchoring them into the blockchain, which means that they cannot be tampered with later on and lastly, the system can validate that the modifications applied to the state are valid and verify that they obey the rules outlined next. 1) the ontology must always be consistent, 2) a party is only allowed to modify $\metaop$ introduced by them, 3) a party must not be allowed to conclude statements following an issue introduced by them. 

\subsection{Applicability of the protocol to set objectives}
In section \ref{sec:definition_of_dispute} a few objectives that the system should meet are defined. Here an analysis of whether and how they are met by the protocol is provided.
\begin{itemize}

    \item{\textbf{Offline:}} As the dispute is turn based, and the document representing the systems state is disclosed to the other party, they can expand on it as well as validate it offline and then disclose the modified version to the other party etc.

    \item{\textbf{Proof of existence:}} Because both parties have access to the whole disputes state as well as it's the history of it's evolution which additionally is anchored into the blockchain providing proof that a certain state existed at a certain point in time, it is easily possible to verify that an interpretation met the constraints set by the other party as well as proving that a resolution was accepted.

    \item{\textbf{Secrecy of utility and preference:}} No utility functions are shared in the protocol and both parties independently calculate their own ideal interpretation based on their private utility, their preferences however will partially be shared as constraints.

    \item{\textbf{Independence of third party:}} The protocol allows two parties to argue a dispute without a third party making use of the proof of existence a blockchain can give. In most cases however a third party would provide negotiation support or guidance which this protocol can not do. A solution to this is discussed in the section \ref{sec:negotiation_support}.

    \item{\textbf{Possibility of involving a third party:}} As the dispute state is identified by the latest document shared between the parties, it is easily possible to involve a neutral third party to advise on arguments or issues.

    \item{\textbf{Incentivise agreement:}} The protocol does not incentivise agreement and cannot do so as there is no external control that has visibility as to how long the dispute has been going on. In game theory the notion of discount factors exists which potentially could be worked into this system in a way where for each modification done by a party, their numerical constraints are discounted in favour of the other party. 

    \item{\textbf{Proof of identity of involved parties:}} Parties are identified by their public keys which have to be provided with each operation $\metaop$. Using mechanisms outlined in chapter \ref{chapter:key_management} it is then possible to proof the identity of involved parties as well as what they said.

\end{itemize}


\section{Negotiation support and Game theoretic view} \label{sec:negotiation_support}
Many ODR systems provide negotiation support to identify mutually beneficial resolutions to the dispute for both parties, typically using utility functions as well as a mechanism to compute and suggest this interpretation. Approaches like the one in \cite{Bellucci:2004:IAI:1032651.1033678} attempt to provide this interpretation by distributing resources/issues based on trade-off maps, while other approaches like \cite{Ragone:2006:PAO:1124566.1124569} use propositional logic identical to $\Proplang$ defined in section \ref{sec:formalising_dispute}. In general all these approaches are based on the Bargaining game defined by Nash \cite{Nash:bargaining} and expanded on by Rubenstein \cite{Rubenstein} and attempt to find a Nash Equilibrium or Pareto optimal outcome for both parties based on their constraints and utilities. 
One fundamental assumption is, that parties typically don't want to share their utilities and constraints. To this extent, all systems investigated that offer bargaining based negotiation support involve a third party, typically a software system, that knows the utilities and constraints of both parties, while neither party learns their opposing sides ones. The system designed in this work aims to provide a solution to this problem without involving a third party and expanding on the protocol defined in the previous section.


To achieve this, phase 2 of the protocol is split in two distinct phases 2.1 and 2.2. In phase 2.1 parties are allowed to introduce atoms and variables using statements as well as building an ontology, but do not define or share their constraints yet. In phase 2.2 the constraints are defined and shared in a secure way using the following protocol:

\begin{enumerate}
    \item Both parties obtain a shared secret, such that the associated public key for encryption is known to both, the private key however can only be produced when both parties provide their part of the private key.
    \item They define their constraints offline, transform them into an integer linear program as defined in \cite{Ragone2008} and transform the resulting linear program into a secure, privacy preserving linear program as defined in section \ref{sec:background_linear_program}. Ragone et al in \cite{Ragone2008} have shown that this transformation into what they call a MAX-SUM-MBN optimisation problem over utilities, leads to a pareto optimal solution to the bargaining problem.
    \item The transformed linear program is then encrypted using the public key obtained in the first step and added as constraints to the state of the dispute which is then shared wit the other party. The encryption with the secret key is necessary as it would otherwise be possible for the party disclosing their constraints last to probe the constraints of the other party to identify several valid interpretations and hence gaining an unfair advantage.
    \item Once both parties are in possession of the encrypted, privacy preserving linear programming constraints of the counterparty, they jointly compute the private key and can now compute a solution to the linear program that maximises their utility. Optionally, the utility can be encrypted and shared as well if e.g. both parties agree that the resolution proposed by the system will be accepted.
\end{enumerate}
In phase 3, identical to the protocol defined in the previous section, acceptance of an interpretation is stated by both parties and the dispute is concluded or withdrawn from. It is possible to expand on this using terms and conditions and essentially making both parties sign that they will agree to the resolution proposed by the system as it must match their constraints but might not be what they hoped for, resulting in a process that more closely resembles adjudication than mediation.

The modifications to the protocol still satisfy the objectives set in the previous section with two differences:
\begin{itemize}
    \item\textbf{Possibility of involving a third party:} It is still possible to involve a third party as the language $\Proplang$ as well as the ontology $\Ontology$ is shared openly. This way the third party can advise on how to build the constraints, but is not able to view the constraints already specified by the parties.

    \item\textbf{Incentivise agreement:} In the case where a mediation like approach is chosen, where both parties have to explicitly agree on an interpretation $\Interpretation$, it is impossible to incentivise an agreement using this system. In the case where an adjudication like approach is chosen however, both parties are incentivised to provide honest constraints based on $\Proplang$ and as soon as the constraints and are satisfiable, a resolution must be accepted. This however still does not provide an incentive to progress to phase 2.2 quickly. 
\end{itemize}
While this design meets most of the criteria that are typically set by the literature, some problems remain. In particular secrecy of utility functions and constraints as well as incentive to conclude a dispute quickly. The first problem, while partially addressed leaves the problem that once the constraints and potentially the utility are decrypted, either party has the ability to probe the constraints using brute force and eventually reverse engineering them. As solving integer linear programs is NP-Hard in the general case this may be prohibitively expensive but it is a problem that is left for future research. The second, more important issue is a way to incentivise parties to reach a conclusion as quickly as possible. To be able to do this, it would be necessary that a third party system can inspect the progress and check for possible resolutions independently of the dispute and impose penalties on the parties for delaying the process. Using the system designed in this work this is not possible as only the hash of a document is anchored and unless a party receives a copy of the original document, they have no way to inspect what's in it. This as well is a problem left for future research and briefly discussed in section \ref{sec:future_work}.

\chapter{Conclusion and Future Work}
In this chapter the work is concluded with a summary of the project and achievements with an outline of some problems of blockchains with respect to the domain of ADR as well as a brief discussion about future work that could not be addressed in this work due to the projects scope, time limitations and the fact that I had to work on it alone instead of the originally anticipated team.

\section{Conclusion} \label{sec:conclusion}
As already mentioned in section \ref{sec:research_outcomes}, all of the set objectives were met, even though I would have liked to have progressed the work further. A prototype of a blockchain agnostic anchoring tool was successfully developed and used for a prototype web page that enables document disclosure. Based on this system a domain specific language was designed that would enable parties to argue a dispute using the developed anchoring system as well as a mechanism for negotiation support was designed that would allow to replace a third party system holding secret constraints and utilities with multi-party computation and blockchains. 

One of the major findings however was, that blockchains are not as well suited to the domain of online dispute resolution as was originally assumed. The main hindrance is that people are usually not willing to openly share their utilities or preference constraints with other parties as they could gain a disadvantage from their counterparty knowing. Developing a system like this on a blockchain is not readily possible as one of the main assumptions of most current blockchains, e.g. Ethereum and Bitcoin is, that all the data stored in the blockchain is public and can be seen by everyone. This particularly is a very interesting finding that is left to be researched in the future.

\section{Future Work} \label{sec:future_work}
This section briefly outlines the areas that due to the scope of the project could not be finished and had to be left for future research. The areas are using multi-party computation for disclosure of documents that are confidential, implement the missing features that form the gap between the official Tierion API and the API provided by this prototype, include a key management system into the prototype as well as investigate using zk-SNAKRs as used in ZCash to proof that a resolution to a dispute exists without sharing any other information.

Disclosure using multi-party computation instead of a distinct symmetric key has the benefit that corrupting one party does not reveal enough information to unlock the document as well as it can provide more flexibility as to how documents are shared between parties.

The official tierion API as of the time of writing has better defined error handling and messages than the API implemented as well as some extra features to subscribe for notifications when datastores change. Because the system implemented as part of this work is intended to be open sources as an alternative to Tierion, this will have to be rectified before this can happen.

Key Management, one very important topic that was mostly neglected in this thesis needs to be investigated more and included into the prototype system, as otherwise any party will be able to deny they are the party that participated in a dispute, which must not be possible.

The probably largest topic left for future research is negotiation and negotiation support in a system that can monitor the state of all disputes, impose penalties for delays as well as provide perfect secrecy of utility and preference constraints. One possible angle to address this is using so called zk-SNARKs as used in ZCash to proof that a resolution exists. 

\bibliographystyle{unsrt}
\bibliography{bibliography}
\end{document}
